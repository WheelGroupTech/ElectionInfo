#-----------------------------------------------------------------------------
# process_ess_ballot_files.py
#
# Copyright (c) 2024 Daniel M. Teal
#
# License: MIT License
#
# Python script to process cast vote record and image PDF files generated by
# ES&S ballot scanners.
#-----------------------------------------------------------------------------
"""process_ess_ballot_files.py""" # for pylint
# pylint: disable=line-too-long,unused-variable,too-many-branches
# pylint: disable=too-many-nested-blocks,too-many-statements,too-many-locals
# pylint: disable=broad-exception-caught

# Standard imports
import io
import os
import re
import pprint
import shelve
import time

# 3rd Party imports
import fitz
from PIL import Image
from pyzbar.pyzbar import decode
from pypdf import PdfReader


# Specify the database version for the ES&S CVR data
ESS_CVR_DATA_VERSION = 2

# Complete list of ballot files to be processed
BALLOT_FILES = []

# Complete list of ballot CVRs after processing
BALLOT_CVR_LIST = []


#-----------------------------------------------------------------------------
# ballot_cvr_num_counted_selections()
#-----------------------------------------------------------------------------
def ballot_cvr_num_counted_selections(ballot_cvr):
    """Returns the number of counted selections from the ballot CVR"""

    num_counted_selections = 0

    for cvr_contest in ballot_cvr['Contests']:
        contest_selections = cvr_contest['Selections']
        for selection in contest_selections:
            contest_status = selection['Status']
            if contest_status == 'Counted':
                num_counted_selections += 1

    return num_counted_selections


#-----------------------------------------------------------------------------
# parse_contest()
#-----------------------------------------------------------------------------
def parse_contest(contest_lines, pathname):
    """Parses a contest from the provided contest lines"""

    contest = {}
    num_lines = len(contest_lines)
    overvote = False

    # There should be at least two lines: contest name, vote for line
    if num_lines < 2:
        print(f"Contest Lines: {contest_lines}")
        raise ValueError(f"There are less than three lines for a contest in {pathname}")

    # Get the contest name
    contest['Contest'] = contest_lines[0]
    current_line = 1

    # Split the next line which should start with 'Vote For:"
    words = contest_lines[current_line].split(r':')

    # The first part must be 'Vote For'
    if words[0] != r"Vote For":
        print(f"Contest Lines: {contest_lines}")
        raise ValueError(f"Vote For section has '{words[0]}' instead of 'Vote For' in {pathname}")

    # There should only be two parts
    if len(words) != 2:
        print(f"Contest Lines: {contest_lines}")
        raise ValueError(f"Vote For section has {len(words)} sections in {pathname}")

    # Get the number of selections to vote for
    vote_for = int(words[1].strip())
    contest['VoteFor'] = vote_for
    current_line = current_line + 1

    # Get the contest selections
    contest['Selections'] = []
    if vote_for > 0:
        selection = {}
        selection_part = 1
        for line in contest_lines[current_line:num_lines]:

            # Get the selection name
            if selection_part == 1:
                selection['Selection'] = line
                selection_part = 2

            else:
                # Check for parenthesis on the status line.  We should have already combined all long lines
                if re.search(r'\(.*?\)', line):
                    print(f"Contest Lines: {contest_lines}")
                    raise ValueError(f"Selection status has parentheses in {pathname}")

                # Check for an overvote.  If so, replace the selection
                # to indicate an overvote
                if line == 'Overvoted':
                    selection['Selection'] = line
                    overvote = True

                selection['Status'] = line

                # We're done parsing this contest so we'll add it to the list
                contest['Selections'].append(selection)

                # Reset for the next contest selection
                selection = {}
                selection_part = 1

    # Check the number of selections for the contest
    if overvote is False:
        if vote_for != len(contest['Selections']):
            print(f"Contest Lines: {contest_lines}")
            print(f"VoteFor: {vote_for} Selections: {contest['Selections']}")
            raise ValueError(f"Vote For count does not match number of selections in {pathname}")
    else:
        if vote_for >= len(contest['Selections']):
            print(f"Contest Lines: {contest_lines}")
            print(f"VoteFor: {vote_for} Selections: {contest['Selections']}")
            raise ValueError(f"Vote For count is not less than the number of selections in {pathname}")

    return contest


#-----------------------------------------------------------------------------
# parse_cvr_header_line()
#
# This function parses the ballot cvr header line to add it to the ballot_cvr
# object.
#
# Example:
#
#   Cast Vote Record: 153,023
#   Poll Place: ED Vote Center
#   Precinct: 1752R
#   Ballot Style: REP 1752R [ Sheet Number 1 ]
#   Party: Republican
#   Tabulator CVR: 06fde5b4f6b37a43
#   Machine Serial: DS200 - 0319330715
#   Blank Ballot: NO
#   Reporting Group: Election Day
#-----------------------------------------------------------------------------
def parse_cvr_header_line(ballot_cvr, line):
    """Parses the CVR header line from the provided data"""

    words = line.split(r':')
    is_contest_section = False

    # Strip of leading whitespace from the value
    if len(words) > 1:
        value = words[1].strip()

        if words[0] == 'Cast Vote Record':
            ballot_cvr['CastVoteRecord'] = value

        elif words[0] == 'Poll Place':
            ballot_cvr['PollPlace'] = value

        elif words[0] == 'Precinct':
            ballot_cvr['Precinct'] = value

        elif words[0] == 'Ballot Style':
            ballot_cvr['BallotStyle'] = value

        elif words[0] == 'Tabulator CVR':
            ballot_cvr['TabulatorCVR'] = value

        elif words[0] == 'Machine Serial':
            ballot_cvr['MachineSerial'] = value

        elif words[0] == 'Blank Ballot':
            ballot_cvr['Blank'] = value

        elif words[0] == 'Reporting Group':
            ballot_cvr['ReportingGroup'] = value

    # Look for the start of the contests section of the CVR
    if words[0] == 'Contests':
        is_contest_section = True

    return is_contest_section


#-----------------------------------------------------------------------------
# obtain_ballot_from_cvr()
#
# This function obtains the ballot info from the specified cvr, parses it, and
# creates a ballot_cvr object to return
#
# Example of a contest:
#
#   REP President (20020)
#   Vote For: 1
#   Donald J. Trump (20555)
#   Counted
#
# Example of an undervote:
#
#   Rep United States Senator (20122)
#   Vote For: 1
#   Undervoted
#   Undervoted
#
# Example of an overvote:
#
#   REP Proposition 6 (26626)
#   Vote For: 1
#   Yes (26628)
#   Overvoted
#
#   No (26630)
#   Overvoted
#-----------------------------------------------------------------------------
def obtain_ballot_from_cvr(ballot_cvr):
    """Obtains the text from the specified pathname"""

    # Parse the CVR PDF file to obtain the text
    reader = PdfReader(ballot_cvr['CvrPathname'])
    text = ""
    for page in reader.pages:
        text += page.extract_text() + "\n"

    # Set things up for parsing
    is_contest_section = False
    contests = []
    contest_lines = []
    append_next_line = False

    # Parse the text into the ballot CVR record
    for line in text.splitlines():
        line = line.strip()

        # Parse the top of the CVR if we are not looking at the contest section
        if is_contest_section is False:
            is_contest_section = parse_cvr_header_line(ballot_cvr, line)

        # Parse the contests from the CVR - skipping blank lines
        elif len(line) > 2:

            # Check if the line has "Vote For:" in it.  This indicates
            # a contest and how many selections can be made.
            if re.search(r'Vote For:', line, flags=re.IGNORECASE):

                if len(contest_lines) > 2:

                    # If there are more than 2 lines already in the list, then this "Vote For:"
                    # is for the next contest.  We need to pop off the last line and parse it.
                    last_line = contest_lines.pop()
                    cvr_contest = parse_contest(contest_lines, ballot_cvr['CvrPathname'])
                    contests.append(cvr_contest)

                    # Start the current contest by adding the line we removed
                    contest_lines = []
                    contest_lines.append(last_line)

                contest_lines.append(line)

            # If the line contains one of the vote values, then just add it
            elif line == 'Overvoted':
                contest_lines.append(line)
            elif line == 'Undervoted':
                contest_lines.append(line)
            elif line == 'Counted':
                contest_lines.append(line)

            # Check if there are no parentheses.  Every contest and selection has a
            # reference number in parentheses.  If the name is too long, it will
            # wrap around onto the next line.
            elif not re.search(r'\((\d+)\)', line):

                # Check for a VERY long line that wraps around more than one line.
                # If so, we'll add it to the previous line in the list
                if append_next_line is True:
                    contest_lines[-1] += f" {line}"
                else:

                    # Append the line to the list, but set the flag to append the next line
                    contest_lines.append(line)
                    append_next_line = True

            else:

                # Append this line to the previous one if needed, otherwise add it to the list
                if append_next_line is True:
                    contest_lines[-1] += f" {line}"
                    append_next_line = False
                else:
                    contest_lines.append(line)

    # Parse the remaining contest lines and add the contest to the contest list if successful
    cvr_contest = parse_contest(contest_lines, ballot_cvr['CvrPathname'])
    contests.append(cvr_contest)

    # Add the list of contests to the ballot cvr
    ballot_cvr['Contests'] = contests

    return ballot_cvr


#-----------------------------------------------------------------------------
# obtain_barcodes_from_ballot_image()
#
# This function obtains the barcode values from the specified ballot image PDF.
#
# Example of the barcode list:
#
#  ['00000878',                           BallotHeaderBarcode (optional)
#   '0000006059000054155000003500',       BallotStyleBarcode  (required)
#   '092311', '013911', '016111',
#   '172911', '172311', '092811',
#   '174711', '174111', '173511',         Barcodes (i.e. ballot selections)
#   '010621', '175911', '175311',
#   '094811', '011121', '011621',
#   '095611', '014611', '012511',
#   '094211', '093411', '015311',
#   '014121', '012121', '012921',
#   '091821', '090921', '015121',
#   '094721', '093821', '092821',
#   '171821', '095521', '170821',
#   '173621', '172721']
#
# The six digit barcode values represent the location of the ovals on a mark-
# sense ballot (i.e. mail/pre-printed ballot).  The ballot is organized into
# a grid of rows 0.5 cm tall and 0.8 cm wide.  The six digits follow the
# pattern CCRRSP:
#   - CC:  two-digits representing the grid column
#   - RR:  two-digits representing the grod row
#   - S:   The side of the ballot, 1 for the front, 2 for the back
#   - P:   The page of the ballot, 1 unless it is a multi-page ballot
#
# ES&S Express Vote Ballot Reference:
# https://securiosa.com/posts/deconstructing_expressvote_records.html
#-----------------------------------------------------------------------------
def obtain_barcodes_from_ballot_image(ballot_cvr):
    """Obtains barcodes from a ballot image"""

    # Initialize the barcodes for a ballot image
    ballot_cvr['BallotStyleBarcode'] = ""
    ballot_cvr['BallotHeaderBarcode'] = ""
    barcode_values = []

    # Ensure that we have an image file.  Some counties use Direct-Recording Electronic
    # (DRE) voting machines that do not provide a ballot image
    if not ballot_cvr['ImagePathname']:
        return barcode_values

    # Open the specified PDF file
    pdf_image = fitz.open(ballot_cvr['ImagePathname'])

    # Load the first page of the ballot image and get the image info from it
    page = pdf_image.load_page(0)
    image_list = page.get_images(full=True)

    # Ensure that we have a single image
    if len(image_list) != 1:
        return barcode_values

    # Extract the image from the PDF
    base_image = pdf_image.extract_image(1)

    # image_ext = base_image['ext']
    # image_smask = base_image['smask']
    # image_width = base_image['width']
    # image_height = base_image['height']
    # image_colorspace = base_image['colorspace']
    # image_bpc = base_image['bpc']
    # image_xres = base_image['xres']
    # image_yres = base_image['yres']
    # image_cs_name = base_image['cs-name']
    image_bytes = base_image["image"]

    # Convert the PNG bytes to an Image object
    png_buffer = io.BytesIO(image_bytes)
    image_png = Image.open(png_buffer)
    image_png = image_png.convert("RGBA")

    # Create a new background image
    background = Image.new("RGB", image_png.size, (255, 255, 255))

    # Paste the PNG onto the background, using its alpha channel as mask
    background.paste(image_png, mask=image_png.split()[3])  # 3 is the alpha channel

    # Save the background in JPEG format to the JPEG buffer
    jpg_buffer = io.BytesIO()
    background.save(jpg_buffer, "JPEG", quality=100)
    jpg_buffer.seek(0)

    # Open the JPEG buffer as an Image object
    image_file_jpg = Image.open(jpg_buffer)

    # Parse the barcodes - ignoring any exceptions generated
    try:
        barcodes = decode(image_file_jpg)
    except Exception:
        pass

    # Process each detected barcode
    for barcode in barcodes:

        # Extract barcode data and type
        barcode_data = barcode.data.decode("utf-8")
        barcode_data_len = len(barcode_data)
        barcode_type = barcode.type

        # Add the barcode if it is CODE128 to the front of the list
        if barcode_type == 'CODE128':

            if barcode_data_len == 28:
                ballot_cvr['BallotStyleBarcode'] = barcode_data

            elif barcode_data_len == 8:
                ballot_cvr['BallotHeaderBarcode'] = barcode_data

            elif barcode_data_len == 6:
                barcode_values.insert(0, barcode_data)

            else:
                raise ValueError(f"{ballot_cvr['ImagePathname']} unknown barcode data {barcode_data}")

        else:
            raise ValueError(f"{ballot_cvr['ImagePathname']} unknown barcode type {barcode_type}")

    # Ensure that we have a barcode for the ballot style.  Almost every ES&S ballot card also has a
    # barcode for the ballot header, but it does not exist for certain software versions and
    # configurations.
    if len(barcode_values) > 0 and len(ballot_cvr['BallotStyleBarcode']) != 28:
        raise ValueError(f"{ballot_cvr['ImagePathname']} unknown or missing ballot style barcode {ballot_cvr['BallotStyleBarcode']}")

    return barcode_values


#-----------------------------------------------------------------------------
# analyze_ballot_files()
#
# This function analyzes all of the CVR and image files identified in the master list.
#-----------------------------------------------------------------------------
def analyze_ballot_files():
    """Analyze ballot CVR and image files from the master list"""

    num_ballot_cvrs = 0

    for ballot_file in BALLOT_FILES:

        # Parse the ballot CVR file
        ballot_cvr = obtain_ballot_from_cvr(ballot_file)

        # Obtain barcodes from the image file
        ballot_cvr['Barcodes'] = obtain_barcodes_from_ballot_image(ballot_file)

        # If we have barcodes from the ballot, check the number of contest selections
        # with the number of barcodes
        num_ballot_barcodes = len(ballot_cvr['Barcodes'])
        if num_ballot_barcodes > 0:
            num_ballot_selections = ballot_cvr_num_counted_selections(ballot_cvr)

            if num_ballot_barcodes != num_ballot_selections:
                raise ValueError(f"{ballot_cvr['CvrPathname']} Num barcodes {num_ballot_barcodes} Num Selections {num_ballot_selections}")

        BALLOT_CVR_LIST.append(ballot_cvr)
        num_ballot_cvrs = len(BALLOT_CVR_LIST)

        # Print out a status message every 1000 ballot CVR files
        if num_ballot_cvrs % 1000 == 0:
            print(f"Analyzed {num_ballot_cvrs} ballot CVRs")


#-----------------------------------------------------------------------------
# generate_file_list()
#
# This function analyzes all of the files in the specified directory and
# subdirectories.
#-----------------------------------------------------------------------------
def generate_file_list(dirname):
    """Generates list of ballot CVR files to be processed"""

    num_ballot_cvrs = 0
    num_ballot_images = 0

    for dirpath, dirnames, filenames in os.walk(dirname):
        for filename in filenames:
            if re.search(r'c.pdf', filename, flags=re.IGNORECASE):

                # Create the pathname to the CVR file
                cvr_pathname = os.path.join(dirpath, filename)
                image_pathname = ""

                # Get the start of the filename (i.e. '190234' from '190234c.pdf')
                filename_len = len(filename)
                filename_len = filename_len - 5
                if filename_len > 0:
                    filename_number = filename[:filename_len]

                    # Use the start of the filename to find the associated image pathname
                    image_filename = filename_number + 'i.pdf'
                    image_pathname = os.path.join(dirpath, image_filename)
                    if os.path.exists(image_pathname):
                        num_ballot_images = num_ballot_images + 1
                    else:
                        image_pathname = ""

                # Obtain a ballot CVR from the pathname
                ballot_cvr = {'CvrPathname':cvr_pathname}
                ballot_cvr['ImagePathname'] = image_pathname

                # Add it to the list
                BALLOT_FILES.append(ballot_cvr)

                num_ballot_cvrs = len(BALLOT_FILES)
                if num_ballot_cvrs % 1000 == 0:
                    print(f"Identified {num_ballot_cvrs} ballot CVRs")

    print(f"Identified a total of {num_ballot_cvrs} ballot CVRs and {num_ballot_images} ballot images")


#-----------------------------------------------------------------------------
# process_ballot_cvr_contests()
#-----------------------------------------------------------------------------
def process_ballot_cvr_contests(barcode_ballots_only):
    """Processes all of the ballot CVR objects looking at the contest data"""

    contests = {}

    ballot_with_barcodes_count = 0

    # Process every contest in every ballot_cvr object
    for ballot_cvr in BALLOT_CVR_LIST:

        # Increment the count of ballots with barcodes
        if len(ballot_cvr['Barcodes']) > 0:
            ballot_with_barcodes_count += 1

        # Check if we are only processing ballots with barcodes
        if barcode_ballots_only and len(ballot_cvr['Barcodes']) == 0:
            continue

        for cvr_contest in ballot_cvr['Contests']:

            # Get the contest name, voter selection(s), and count status
            contest_name = cvr_contest['Contest']
            contest_selections = cvr_contest['Selections']
            contest_overvote = False

            try:
                # Find the contest in the master list of contests
                contest = contests[contest_name]

                for selection in contest_selections:
                    contest_selection = selection['Selection']
                    contest_status = selection['Status']

                    try:
                        # Find the voter selection in the contest
                        if contest_status == 'Counted':
                            current_vote_count = contest[contest_selection]
                            contest[contest_selection] = current_vote_count + 1
                        elif contest_status == 'Undervoted':
                            current_vote_count = contest['Undervoted']
                            contest['Undervoted'] = current_vote_count + 1
                        elif contest_status == 'Overvoted':

                            # Overvote counts are limited to the number specified by 'Vote For:'
                            if contest_overvote is False:
                                current_vote_count = contest['Overvoted']
                                vote_for = cvr_contest['VoteFor']
                                contest['Overvoted'] = current_vote_count + vote_for
                                contest_overvote = True

                    except KeyError:

                        # The voter selection has not been added yet, so we will
                        # add it and a count of 1
                        contest[contest_selection] = 1

            except KeyError:

                contest = {}
                contest['Undervoted'] = 0
                contest['Overvoted'] = 0

                for selection in contest_selections:
                    contest_selection = selection['Selection']
                    contest_status = selection['Status']

                    try:
                        # Find the voter selection in the contest
                        if contest_status == 'Counted':
                            current_vote_count = contest[contest_selection]
                            contest[contest_selection] = current_vote_count + 1
                        elif contest_status == 'Undervoted':
                            current_vote_count = contest['Undervoted']
                            contest['Undervoted'] = current_vote_count + 1
                        elif contest_status == 'Overvoted':
                            if contest_overvote is False:
                                current_vote_count = contest['Overvoted']
                                vote_for = cvr_contest['VoteFor']
                                contest['Overvoted'] = current_vote_count + vote_for
                                contest_overvote = True

                    except KeyError:

                        # The voter selection has not been added yet, so we will
                        # add it and a count of 1
                        contest[contest_selection] = 1

                # Add the contest to the master list
                contests[contest_name] = contest

    print(f"{ballot_with_barcodes_count} ballots have barcodes")

    pprint.pp(contests)


#-----------------------------------------------------------------------------
# process_ballot_barcodes()
#-----------------------------------------------------------------------------
def process_ballot_barcodes():
    """Processes all of the ballot barcodes obtained from the ballots"""

    barcodes = {}


    # Process every ballot barcode
    for ballot_cvr in BALLOT_CVR_LIST:
        for barcode in ballot_cvr['Barcodes']:

            try:
                # Find the barcode in the master list of barcodes
                barcodes[barcode] += 1

            except KeyError:

                barcodes[barcode] = 1

    pprint.pp(barcodes)


#-----------------------------------------------------------------------------
# main()
#-----------------------------------------------------------------------------
def main():
    """Main function"""

    # Analyze the files in the current directory and subdirectories
    generate_file_list(r".")

    # Analyze the ballot CVRs parsed in from the files.
    start_time = time.time()
    analyze_ballot_files()
    end_time = time.time()
    elapsed_seconds = format(end_time - start_time, ".2f")
    print(f"Analyzed a total of {len(BALLOT_CVR_LIST)} ballot CVRs in {elapsed_seconds} seconds")

    # Process all of the ballot CVR contests
    process_ballot_cvr_contests(False)

    # Process the ballot barcodes
    process_ballot_barcodes()

    # Process only ballot CVR contests with barcodes
    process_ballot_cvr_contests(True)

    db = shelve.open('ess_dbfile2')
    db['Version'] = ESS_CVR_DATA_VERSION
    db['Data'] = BALLOT_CVR_LIST
    db.close()


main()
